import duckdb
import os
import sys
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger("DailyReporting")

def run_daily_queries():
    try:
        # Configuration from environment or defaults for local testing
        db_path      = os.environ.get("DB_PATH", "data/outputs/scalable.db")
        s3_endpoint  = os.environ.get("CATALOG_S3_ENDPOINT", "localhost:9100").replace("http://", "")
        s3_access    = os.environ.get("AWS_ACCESS_KEY_ID", "admin")
        s3_secret    = os.environ.get("AWS_SECRET_ACCESS_KEY", "password")
        # Pointing to the Parquet files generated by the Iceberg table
        gold_s3_path = os.environ.get("GOLD_S3_PATH", "s3://warehouse/gold/user_peaks/data/*.parquet")
    except Exception as e:
        logger.error(f"Env Error: {e}")
        sys.exit(1)

    with duckdb.connect(db_path) as db:
        # Initialize DuckDB S3 capabilities
        db.execute("INSTALL httpfs; LOAD httpfs;")
        db.execute(f"""
            SET s3_endpoint='{s3_endpoint}';
            SET s3_access_key_id='{s3_access}';
            SET s3_secret_access_key='{s3_secret}';
            SET s3_use_ssl=false;
            SET s3_url_style='path';
        """)

        logger.info("Syncing S3 Gold Layer to local DuckDB...")
        db.execute(f"CREATE OR REPLACE TABLE gold_peaks AS SELECT * FROM read_parquet('{gold_s3_path}')")

        print("\n" + "="*50 + "\nREPORT: TOP 10 USERS BY PEAK ACTIVITY\n" + "="*50)
        db.execute("""
            SELECT 
                user_name, 
                SUM(count) AS total_peak_listens,
                MAX(listened_date) as last_peak_date
            FROM gold_peaks 
            GROUP BY 1 
            ORDER BY 2 DESC 
            LIMIT 10
        """).show()

        print("\n" + "="*50 + "\nREPORT: 7-DAY ACTIVE USER TREND\n" + "="*50)
        db.execute("""
            WITH daily_users AS (
                SELECT listened_date as d, user_name FROM gold_peaks GROUP BY 1, 2
            ),
            active_counts AS (
                SELECT 
                    curr.d as report_date, 
                    COUNT(DISTINCT past.user_name) as rolling_7d_active_users
                FROM daily_users curr
                LEFT JOIN daily_users past ON past.d BETWEEN (curr.d - INTERVAL 6 DAYS) AND curr.d
                GROUP BY curr.d
            )
            SELECT report_date, rolling_7d_active_users 
            FROM active_counts 
            ORDER BY report_date DESC 
            LIMIT 7
        """).show()

if __name__ == "__main__":
    run_daily_queries()